Pachitto Monster

現在、Java を利用したポートフォリオを作成しようと考えています。
Java を用いて簡単なゲームを作成することは可能ですか？

ゲーム開発を通じて、オブジェクト指向プログラミング、アルゴリズム、データ構造、GUI設計などの重要な概念を学ぶことができます。また、これらのゲームはポートフォリオ作品として優れており、あなたのプログラミングスキルを効果的にアピールできるでしょう。
初めてのゲーム開発では、まずは小規模なプロジェクトから始め、徐々に複雑なゲームに挑戦していくことをお勧めします。

『オブジェクト指向プログラミング、アルゴリズム、データ構造、GUI設計』を全て含んだゲーム実装のアイディアを出してください。
ご要望の要素を全て含むゲーム実装のアイデアとして、「進化する生態系シミュレーションゲーム」を提案します。このゲームは複雑性と学習要素が豊富で、オブジェクト指向プログラミング、アルゴリズム、データ構造、GUI設計の全てを網羅できる良い例となります。

ゲーム概要：
プレイヤーは仮想の生態系を管理し、さまざまな生物種を進化させていきます。環境条件を調整しながら、生物の多様性と生態系の安定性を保つことが目標です。

主な機能と実装ポイント：

1. オブジェクト指向プログラミング
- 生物クラスの階層構造（抽象クラス「生物」を継承した「植物」「動物」「微生物」など）
- インターフェースの活用（「捕食者」「被食者」インターフェースなど）
- カプセル化、継承、ポリモーフィズムの活用


2. アルゴリズム
- 遺伝的アルゴリズムを用いた生物の進化シミュレーション
- A*アルゴリズムによる生物の経路探索
- 生態系バランスを保つための最適化アルゴリズム


3. データ構造
- グラフを用いた食物連鎖の表現
- 四分木を使用した空間分割と衝突検出の最適化
- ヒープを利用したイベントの優先順位付け


4. GUI設計
- JavaFXを使用したインタラクティブな生態系マップの表示
- リアルタイムで更新されるグラフや統計情報の可視化
- ユーザーによる環境パラメータの調整インターフェース


追加機能：

5. マルチスレッディング
- 並列処理による生物の行動シミュレーションの高速化
- バックグラウンドでの定期的な環境更新

6. デザインパターン
- オブザーバーパターンを用いた環境変化の通知システム
- ファクトリーパターンによる生物インスタンスの生成
- シングルトンパターンを使用した環境管理クラス

7. ファイル I/O とシリアライゼーション
- 生態系の状態の保存と読み込み機能
- CSVエクスポート機能によるデータ分析の促進

8. データベース連携
- 生物種や環境パラメータのマスターデータをSQLiteで管理

このプロジェクトは、段階的に機能を追加していくことができます。基本的な生態系シミュレーションから始め、徐々に複雑な機能を実装していくことで、大規模なプロジェクトを無理なく完成させることができます。


また、このゲームは教育的な要素も含んでおり、生物学や生態学の基本概念を学ぶツールとしても活用できる点が特徴です。


このプロジェクトを通じて、Javaの幅広い機能を活用し、複雑なシステムの設計と実装を経験することができます。同時に、興味深いゲームメカニクスの創造にも取り組むことができ、技術力とクリエイティビティの両方をアピールできる優れたポートフォリオ作品となるでしょう。

ありがとうございます。上記のアイディアを借りて、ポケモンのようなゲームを実装しようかと考えたのですが、いかがでしょうか。
ポケモンのようなゲームを実装するのは素晴らしいアイデアです！これは、先ほど提案した生態系シミュレーションゲームの概念を、より親しみやすく、エンターテイメント性の高いフォーマットに適用することができます。以下に、ポケモン風ゲームの実装案を示します：

1. オブジェクト指向プログラミング
- 抽象クラス「生物」を基に「ポケモン」クラスを作成
- タイプ（火、水、草など）ごとに子クラスを作成
- 「トレーナー」クラスの実装

2. アルゴリズム
- バトルシステムの実装（ダメージ計算、タイプ相性など）
- レベルアップと進化のメカニズム
- 簡単なAIアルゴリズムによる敵トレーナーの行動決定

3. データ構造
- ポケモンのステータスや技を管理するためのカスタムデータ構造
- マップデータの格納と管理（2次元配列やグラフ）
- プレイヤーのインベントリ管理（リストやキュー）

4. GUI設計
- JavaFXを使用したゲームウィンドウの作成
- キャラクター移動、バトル画面、メニュー画面の実装
- アニメーションの実装（ポケモンの動き、技のエフェクトなど）

追加機能：

5. マップ生成とナビゲーション
- プロシージャル生成によるランダムマップの作成
- A*アルゴリズムを用いたNPCの経路探索

6. セーブ＆ロードシステム
- プレイヤーの進行状況、所持ポケモン、アイテムなどの保存と読み込み

7. クエストシステム
- メインストーリーとサイドクエストの実装

8. 通信対戦（オプション）
- ソケットプログラミングを用いた簡単なオンライン対戦機能

実装のポイント：

1. まずは基本的な機能（キャラクター移動、簡単なバトルシステム）から始め、徐々に機能を追加していきます。

2. ポケモンのデータ（名前、タイプ、ステータス、技など）はJSONやCSVファイルで管理し、ゲーム起動時に読み込むようにします。

3. デザインパターンを適切に使用します：
- ファクトリーパターン：ポケモンの生成
- オブザーバーパターン：バトル中のステータス変化の通知
- ステートパターン：ゲームの状態管理（フィールド、バトル、メニューなど）

4. 効果音や簡単なBGMを追加し、ゲーム体験を向上させます。

5. ユニットテストを書いて、核となる機能（ダメージ計算、レベルアップロジックなど）の正確性を確保します。

このプロジェクトは、先に提案した生態系シミュレーションの多くの要素を含みつつ、より親しみやすく、楽しいゲームとして実装できます。また、拡張性が高いので、最初は基本的な機能から始めて、徐々に複雑な要素を追加していくことができます。


このようなプロジェクトは、Javaの多様な機能を活用し、ゲーム開発の基本的な概念を学ぶ excellent な機会となるでしょう。また、完成したゲームはポートフォリオとして非常に印象的な作品になると思います。


ありがとうございます。
上記実装するにあたり、必要な開発言語などを教えてください。例えば、言語も Java 以外に、HTML/CSS など必要でしょうか？それとも単純なデザインであれば Java のみで実装可能でしょうか？
音声などは特に用意するつもりはありません。ポートフォリオとして簡単に提出できるよう、バージョン管理等は Github を利用したいと考えています。また、基本的には AWS 上で動くようにしたいです。
データベースは DynamoDB か RDS。開発環境は基本的には Visual Studio Code (Java 8 の環境は用意済み) で実装し、その後 EC2 等のコンピューティングに載せようと思います。
ご質問ありがとうございます。ご提案の開発環境と計画は素晴らしいです。以下に、ご要望に基づいた開発言語と環境の詳細をお伝えします：

1. 主要開発言語：
- Java（Java 8）

2. フロントエンド：
- JavaFX：Java のみでGUIを実装可能です。HTML/CSSは不要です。
- 単純なデザインであれば、Java と JavaFX だけで十分実装できます。

3. バージョン管理：
- GitHub：適切な選択です。

4. データベース：
- Amazon DynamoDB：NoSQLデータベースで、ゲームデータの保存に適しています。
- Amazon RDS：リレーショナルデータベースが必要な場合はこちらを使用。

5. 開発環境：
- Visual Studio Code：Java 開発に適しています。以下の拡張機能を追加すると良いでしょう：
- Language Support for Java(TM) by Red Hat
- Debugger for Java
- Java Test Runner
- Maven for Java

6. デプロイ環境：
- AWS EC2：Javaアプリケーションのホスティングに適しています。

7. ビルドツール：
- Maven or Gradle：依存関係の管理とビルドプロセスの自動化に使用。

8. 追加ライブラリ（必要に応じて）：
- Jackson：JSONパース用
- JUnit：単体テスト用


実装手順：

1. ローカル環境（Visual Studio Code）でJavaとJavaFXを使用して開発を進めます。

2. GitHubでバージョン管理を行いながら、機能を段階的に実装します。

3. ローカルでのテストが完了したら、AWS EC2インスタンスを準備します。

4. EC2インスタンスにJava環境をセットアップし、アプリケーションをデプロイします。

5. DynamoDBまたはRDSをセットアップし、アプリケーションから接続できるよう設定します。

6. 必要に応じて、AWS Elastic Beanstalkを使用して、デプロイプロセスを簡素化することもできます。

注意点：
- JavaFXアプリケーションをEC2上で実行する場合、X Window Systemが必要になる可能性があります。その場合、VNCサーバーのセットアップが必要になるかもしれません。

- あるいは、サーバーサイドのロジックはEC2で実行し、クライアントアプリケーションは別途配布するという方法もあります。

このアプローチで、Java単独でゲームを実装し、AWSサービスを活用してスケーラブルなアプリケーションを構築することができます。また、このプロジェクトを通じて、フルスタック開発とクラウドデプロイメントのスキルをアピールすることができるでしょう。


では、まずはシンプルなゲームを実装します。
タイプは「火、草、水」の三種類。キャラクターは10種類ほどを考えています。
マップもまずは小さなものを一面だけ。主人公がマップ内の草むらを歩くと、ランダムでモンスターとエンカウントするようにします。
バトルはじゃんけん形式で行います。じゃんけんゲームはすでに実装しているので、こちらを利用します。

まず、下記は最終実装の想定です。
<final_project>
1. プロジェクト構造:
```
PACHITTO_MONSTER/
├── src/
│   └── main/
│       ├── java/
│       │   └── com/
│       │       └── sakufuyu/
│       │           ├── model/
│       │           │   ├── Battle.java
│       │           │   ├── Character.java
│       │           │   ├── Monster.java
│       │           │   ├── MonsterData.java
│       │           │   ├── Player.java
│       │           │   └── Type.java
│       │           ├── view/
│       │           │   ├── BattleView.java
│       │           │   ├── GameView.java
│       │           │   ├── MapView.java
│       │           │   └── PlayerView.java
│       │           ├── controller/
│       │           │   ├── BattleController.java
│       │           │   └── GameController.java
│       │           ├── repository/
│       │           │   └── MonsterRepository.java
│       │           └── App.java
│       └── resources/
│           ├── data/
│           │   └── monsters.csv
│           └── images/
│               ├── tiles/
│               │   ├── road.jpeg
│               │   └── grass.jpeg
│               └── characters/
│                   └── player.jpeg
├── target/
├── .gitignore
├── pom.xml
└── README.md
```

2. クラス設計:

a. モデル (model/)
- Character.java (抽象クラス)
- Monster.java (Character を継承)
- Player.java (Character を継承)
- Type.java (列挙型: FIRE, GRASS, WATER)
- Battle.java (バトルロジック)

b. ビュー (view/)
- GameView.java (JavaFX のメインビュー)
- MapView.java (マップ表示)
- BattleView.java (バトル画面)

c. コントローラー (controller/)
- GameController.java (ゲーム全体の制御)
- MapController.java (マップ上の動きを制御)
- BattleController.java (バトルの制御)

d. ユーティリティ (util/)
- RandomGenerator.java (ランダム生成ユーティリティ)

3. 実装手順:

1. モデルの実装:
- Character, Monster, Player クラスを実装
- Type 列挙型を定義
- Battle クラスにじゃんけんロジックを実装

2. マップの作成:
- 2D配列を使用して簡単なマップを作成
- マップデータを CSV ファイルで管理し、読み込む機能を実装

3. ビューの実装:
- JavaFX を使用して GameView, MapView, BattleView を作成
- 簡単なグラフィックス（四角形や円など）で表現開始

4. コントローラーの実装:
- GameController で全体の流れを制御
- MapController でプレーヤーの移動とエンカウント判定を実装
- BattleController でバトル進行を制御

5. ランダムエンカウント:
- RandomGenerator を使用して、草むら上で一定確率でエンカウントさせる

6. バトルシステム:
- 既存のじゃんけんゲームを Battle クラスに統合
- タイプ相性を考慮したダメージ計算を追加

7. データ管理:
- モンスターデータを JSON や CSV で管理し、ゲーム起動時に読み込む

8. テスト:
- JUnit を使用して、各クラスの主要メソッドのユニットテストを作成

4. 拡張アイデア (基本機能実装後):
- モンスター捕獲システムの追加
- プレイヤーの所持モンスター管理機能
- 複数マップの実装と移動機能
- NPCとの会話システム
- 簡単なクエストシステム

実装のポイント:
1. まずは機能を最小限に絞り、動くプロトタイプを作成します。
2. モジュール性を意識し、各クラスの責任を明確にします。
3. ダイアログが同じように実装できない場合、独自のダイアログシステムを作成します。
4. コードの再利用性を高めるため、汎用的な機能はユーティリティクラスに分離します。
5. 定期的にGitHubにコミットし、機能ごとにブランチを作成して開発を進めます。

</final_project>


そして、まずは機能が最小限の、動くプロトタイプを作成します。
実装手順は下記の通りです。まずは基本的な構造を作り、段階的に機能を追加していきます。

<minimum_project>
1. プロジェクトのセットアップ:
- Visual Studio Codeで新しいJavaプロジェクトを作成
- Maven or Gradleをセットアップ（依存関係管理用）
- JavaFXの依存関係を追加

2. 基本的なクラス構造の作成:

a. モデル (src/main/java/model/)
- Character.java (抽象クラス)
- Monster.java
- Player.java
- Type.java (enum)

b. ビュー (src/main/java/view/)
- GameView.java

c. コントローラー (src/main/java/controller/)
- GameController.java

3. 各クラスの基本実装:

App.java
```java
package main.java.com.sakufuyu;

import main.java.com.sakufuyu.controller.GameController;
import main.java.com.sakufuyu.view.GameView;
import javafx.application.Application;
import javafx.stage.Stage;


public class App extends Application {
    private GameView view;
    private GameController controller;

    @Override
    public void start(Stage primaryStage)
    {
        try {
            view = new GameView(primaryStage);
            controller = new GameController(view);
            controller.startGame();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    public static void main(String[] args) {
        launch(args);
    }
}
```

view/BattleView.java
```java
package main.java.com.sakufuyu.view;

import java.io.File;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.VBox;
import javafx.scene.layout.HBox;
import javafx.scene.Scene;
import javafx.stage.Stage;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;

import main.java.com.sakufuyu.model.Monster;

public class BattleView {
    private Stage battleStage;
    private Scene battleScene;
    private VBox layout;
    private Label playerMonsterInfo;
    private Label wildMonsterInfo;
    private Label battleLog;
    private Button rockButton;
    private Button paperButton;
    private Button scissorsButton;
    private Button throwBallButton;
    private Label ballCountLabel;

    private ImageView playerMonsterImage;
    private ImageView wildMonsterImage;
    private static final double MONSTER_IMAGE_SIZE = 100;

    public BattleView() {
        battleStage = new Stage();
        battleStage.setTitle("Battle!");

        // Main layout of battle screen
        layout = new VBox(10);
        layout.setPadding(new Insets(10));
        layout.setAlignment(Pos.CENTER);

        // Area for Info and Images of Monsters
        HBox monsterArea = new HBox(20);
        monsterArea.setAlignment(Pos.CENTER);

        // Player's Monster
        VBox playerSide = new VBox(10);
        playerSide.setAlignment(Pos.CENTER);
        playerMonsterImage = new ImageView();
        playerMonsterImage.setFitWidth(MONSTER_IMAGE_SIZE);
        playerMonsterImage.setFitHeight(MONSTER_IMAGE_SIZE);
        playerMonsterInfo = new Label();
        playerSide.getChildren().addAll(playerMonsterImage, playerMonsterInfo);

        // Wild Monster
        VBox wildSide = new VBox(10);
        wildSide.setAlignment(Pos.CENTER);
        wildMonsterImage = new ImageView();
        wildMonsterImage.setFitWidth(MONSTER_IMAGE_SIZE);
        wildMonsterImage.setFitHeight(MONSTER_IMAGE_SIZE);
        wildMonsterInfo = new Label();
        wildSide.getChildren().addAll(wildMonsterImage, wildMonsterInfo);

        monsterArea.getChildren().addAll(playerSide, wildSide);

        // Battle logs
        battleLog = new Label("Battle Start!!");
        battleLog.setStyle("-fx-font-size: 14px;");

        // Set Battle buttons
        HBox buttonBox = new HBox(10);
        buttonBox.setAlignment(Pos.CENTER);
        rockButton = new Button("Rock");
        paperButton = new Button("Paper");
        scissorsButton = new Button("Scissors");
        buttonBox.getChildren().addAll(rockButton, paperButton, scissorsButton);

        // Set throw ball button
        throwBallButton = new Button("Throw Monster Ball");
        throwBallButton.setStyle(
            "-fx-background-color: #4CAF50;" +
            "-fx-text-fill: white;" +
            "-fx-font-size: 14px;" +
            "-fx-padding: 5px 10px;"
        );
        ballCountLabel = new Label();
        HBox captureBox =  new HBox(10);
        captureBox.setAlignment(Pos.CENTER);
        captureBox.getChildren().addAll(throwBallButton, ballCountLabel);

        layout.getChildren().addAll(
            monsterArea,
            battleLog,
            buttonBox,
            captureBox
        );

        battleScene = new Scene(layout, 600, 400);
        battleStage.setScene(battleScene);
    }

    private Button createStyledButton(String text) {
        Button button = new Button(text);
        button.setStyle(
            "-fx-background-color: #4CAF50;"+
            "-fx-text-fill: white;"+
            "-fx-font-size: 14px;"+
            "-fx-padding: 10px 20px;"
        );
        return button;
    }

    public void showBattle(Monster playerMonster, Monster wildMonster) {
        updateMonsterInfo(playerMonster, wildMonster);
        loadMonsterImages(playerMonster, wildMonster);
        battleLog.setText("A wild " + wildMonster.getName() + " appeared!!");
        battleStage.show();
    }

    private void loadMonsterImages(Monster playerMonster, Monster wildMonster) {
        try {
            // Load player monster image
            String playerImagePath = String.format("/src/main/resources/images/monsters/%s.jpeg", playerMonster.getName());
            File playerFile = new File(new File(".").getCanonicalPath() + playerImagePath);

            if (playerFile.exists()) {
                playerMonsterImage.setImage(new Image(playerFile.toURI().toString()));
            } else {
                // Set default image
                setDefaultMonsterImage(playerMonsterImage);
            }

            // Load wild monster image
            String wildImagePath = String.format("/src/main/resources/images/monsters/%s.jpeg", wildMonster.getName());
            File wildFile = new File(new File(".").getCanonicalPath() + wildImagePath);

            if (wildFile.exists()) {
                wildMonsterImage.setImage(new Image(wildFile.toURI().toString()));
            } else {
                setDefaultMonsterImage(wildMonsterImage);
            }
        } catch (Exception e) {
            e.printStackTrace();
            // Set default image if error occures
            setDefaultMonsterImage(playerMonsterImage);
            setDefaultMonsterImage(wildMonsterImage);
        }
    }

    private void setDefaultMonsterImage(ImageView imageView) {
        try {
            String defaultImagePath = "/src/main/resources/images/monsters/default.jpeg";
            File defaultFile = new File(new File(".").getCanonicalPath() + defaultImagePath);

            if (defaultFile.exists()) {
                imageView.setImage(new Image(defaultFile.toURI().toString()));
            } else {
                System.out.println(defaultFile.toURI().toString() + " file not found");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void updateMonsterInfo(Monster playerMonster, Monster wildMonster) {
        playerMonsterInfo.setText(
            String.format("%s (HP: %d/%d)",
                playerMonster.getName(),
                playerMonster.getHp(),
                playerMonster.getMaxHp())
        );
        wildMonsterInfo.setText(
            String.format("%s (HP: %d/%d)",
                wildMonster.getName(),
                wildMonster.getHp(),
                wildMonster.getMaxHp())
        );
    }

    public void updateBattleLog(String message) {
        battleLog.setText(message);
    }

    public Button getRockButton() {return rockButton;}
    public Button getPaperButton() {return paperButton;}
    public Button getScissorsButton() {return scissorsButton;}

    public void showMessage(String message, Monster wildMonster) {
        layout.getChildren().clear();

        VBox messageLayout = new VBox(20);
        messageLayout.setAlignment(Pos.CENTER);

        ImageView wildMonsterImage = new ImageView();
        wildMonsterImage.setFitWidth(MONSTER_IMAGE_SIZE);
        wildMonsterImage.setFitHeight(MONSTER_IMAGE_SIZE);

        try {
            String wildImagePath = String.format("/src/main/resources/images/monsters/%d-front.jpeg", wildMonster.getId());
            File wildFile = new File(new File(".").getCanonicalPath() + wildImagePath);

            if (wildFile.exists()) {
                wildMonsterImage.setImage(new Image(wildFile.toURI().toString()));
            } else {
                setDefaultMonsterImage(wildMonsterImage);
            }
        } catch (Exception e) {
            e.printStackTrace();
            setDefaultMonsterImage(wildMonsterImage);
        }

        // Display monster name
        Label nameLabel = new Label("A wild " + wildMonster.getName() + " appeared!");
        nameLabel.setStyle("-fx-font-size: 16px;");

        // Display message
        Label messageLable = new Label(message);
        messageLable.setStyle("-fx-font-size: 18px; -fx-text-fill:red;");

        // Add elements to layout
        messageLayout.getChildren().addAll(wildMonsterImage, nameLabel, messageLable);
        layout.getChildren().add(messageLayout);

        battleStage.show();
    }

    // Ball trow functions

    public void updateBallCount(int ballCount) {
        ballCountLabel.setText("Monster Balls: " + ballCount);
    }

    public Button getThrowButton() {
        return throwBallButton;
    }

    public void showCaptureResult(boolean success) {
        String message = success ? "Capture successful!" : "Capure failed..";
        battleLog.setText(message);
    }

    public void close() {
        battleStage.close();
    }
}
```

view/GameView.java
```java
package main.java.com.sakufuyu.view;

import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.control.Button;
import javafx.stage.Stage;

import main.java.com.sakufuyu.model.Player;

public class GameView {
    public static final int MAP_WIDTH = 20;
    public static final int MAP_HEIGHT = 15;
    public static final int TILE_SIZE = 20;
    public static final int SCENE_WIDTH = MAP_WIDTH * TILE_SIZE;
    public static final int SCENE_HEIGHT = MAP_HEIGHT * TILE_SIZE;
    private static final int HEADER_HEIGHT = 40;

    private Stage stage;
    private Scene scene;
    private StackPane gameArea;
    private BorderPane root;
    private MapView mapView;
    private PlayerView playerView;
    public PlayerStatusView playerStatusView;
    private Stage statusStage;
    private Button statusButton;

    public GameView(Stage stage) {
        this.stage = stage;

        // Create main layout
        root = new BorderPane();

        // Create header
        HBox header = createHeader();
        root.setTop(header);

        // Create game area
        gameArea = new StackPane();
        mapView = new MapView(MAP_WIDTH, MAP_HEIGHT);
        playerView = new PlayerView(0, 0);
        gameArea.getChildren().addAll(mapView, playerView);
        root.setCenter(gameArea);

        // Set status window
        statusStage = new Stage();
        statusStage.setTitle("Player Status");
        playerStatusView = new PlayerStatusView();
        Scene statusScene = new Scene(playerStatusView, 300, 400);
        statusStage.setScene(statusScene);

        scene = new Scene(root, SCENE_WIDTH, SCENE_HEIGHT + HEADER_HEIGHT);
        stage.setScene(scene);
        stage.setTitle("Pachitto Monster");
    }

    private HBox createHeader() {
        HBox header = new HBox(10);
        header.setPrefHeight(HEADER_HEIGHT);
        header.setPadding(new Insets(5, 10, 5, 10));
        header.setStyle(
            "-fx-background-color: #333333;" +
            "-fx-border-color: #666666;" +
            "-fx-border-width: 0 0 1 0;"
        );

        // Create status button
        statusButton = new Button("Status");
        statusButton.setStyle(
            "-fx-background-color: #4CF50;" +
            "-fx-text-fill: white;" +
            "-fx-font-size: 14px;" +
            "-fx-padding: 5px 10px;" +
            "-fx-cursor: hand;"
        );

        // Hobar effect
        statusButton.setOnMouseEntered(e ->
            statusButton.setStyle(
                "-fx-background-color: #45a049;" +
                "-fx-text-fill: white;" +
                "-fx-font-size: 14px;" +
                "-fx-padding: 5px 15px;" +
                "-fx-cursor: hand;"
            )
        );

        statusButton.setOnMouseExited(e -> 
            statusButton.setStyle(
                "-fx-background-color: #4CAF50;" +
                "-fx-text-fill: white;" +
                "-fx-font-size: 14px;" +
                "-fx-padding: 5px 15px;" +
                "-fx-cursor: hand;"
            )
        );

        statusButton.setOnAction(e -> toggleStatusWindow());

        header.getChildren().add(statusButton);
        return header;
    }

    private void toggleStatusWindow() {
        if (statusStage.isShowing()) {
            statusStage.close();
        } else {
            // Add player status display
            // playerStatusView = new PlayerStatusView();
            // playerStatusView.setTranslateX(10);
            // playerStatusView.setTranslateY(10);
            // root.getChildren().add(playerStatusView);
            statusStage.setX(stage.getX() + stage.getWidth());
            statusStage.setY(stage.getY());
            statusStage.show();
        }
    }

    public void show() {
        stage.show();
    }

    public Scene getScene() {
        return scene;
    }

    public void movePlayer(int dx, int dy) {
        playerView.move(dx, dy);
        System.out.println("Move player called: dx=" + dx + ", dy=" + dy);  // For debug output
    }

    public MapView getMapView() {
        return mapView;
    }

    public void updatePlayerStatus(Player player) {
        playerStatusView.updateStatus(player);
    }

    public void showMessage(String message) {
        javafx.scene.control.Alert alert = new javafx.scene.control.Alert(
            javafx.scene.control.Alert.AlertType.INFORMATION);
        alert.setTitle("Information");
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.show();
    }
}
```


view/MapView.java
```java
package main.java.com.sakufuyu.view;

import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.image.Image;
import java.io.File;


public class MapView extends Canvas {
    private int[][] map;
    private static final int TILE_SIZE = GameView.TILE_SIZE;
    public static final int ROAD = 0;
    public static final int GRASS = 1;
    public static final int HEALING = 2;

    private Image roadImage;
    private Image grassImage;
    private Image healingImage;

    public MapView(int width, int height) {
        super(width * TILE_SIZE, height * TILE_SIZE);
        map = new int[height][width];

        // Load images
        try {
            String currentPath = new File(".").getCanonicalPath();
            roadImage = new Image(new File(currentPath + "/src/main/resources/images/tiles/road.jpeg").toURI().toString());
            grassImage = new Image(new File(currentPath + "/src/main/resources/images/tiles/grass.jpeg").toURI().toString());
            healingImage = new Image(new File(currentPath + "/src/main/resources/images/tiles/healing.jpeg").toURI().toString());
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("Failed to load images, create map with color");
        }

        // Set temp map data
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                if (x == 5 && y == 5) {
                    map[y][x] = HEALING;
                } else {
                    map[y][x] = (Math.random() > 0.3) ? ROAD:GRASS; // 0: road, 1: grass
                }
            }
        }
        draw();
    }

    public void draw() {
        GraphicsContext gc = getGraphicsContext2D();
        for (int y = 0; y < map.length; y++) {
            for (int x = 0; x < map[y].length; x++) {
                if (map[y][x] == ROAD) {
                    if (roadImage != null) {
                        gc.drawImage(roadImage, x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    } else {
                        gc.setFill(javafx.scene.paint.Color.GRAY);
                        gc.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                } else if (map[y][x] == GRASS) {
                    if (grassImage != null) {
                        gc.drawImage(grassImage, x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    } else {
                        gc.setFill(javafx.scene.paint.Color.GREEN);
                        gc.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                } else {
                    if (healingImage != null) {
                        gc.drawImage(healingImage, x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    } else {
                        gc.setFill(javafx.scene.paint.Color.PINK);
                        gc.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
        }
    }

    public boolean isGrass(int x, int y) {
        return map[y][x] == GRASS;
    }

    public boolean isHealing(int x, int y) {
        if (x < 0 || x >= map[0].length || y < 0 || y >= map.length) {
            return false;
        }
        return map[y][x] == HEALING;
    }
}
```

view/PlayerView.java
```java
package main.java.com.sakufuyu.view;

import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.image.Image;
import java.io.File;

public class PlayerView extends Canvas {
    private int x, y;
    private final int SIZE = GameView.TILE_SIZE;
    private Image playerImage;

    public PlayerView(int startX, int startY) {
        super(GameView.SCENE_WIDTH, GameView.SCENE_HEIGHT);
        this.x = startX;
        this.y = startY;

        try {
            String currentPath = new File(".").getCanonicalPath();
            playerImage = new Image(new File(currentPath + "/src/main/resources/images/characters/player.jpeg").toURI().toString());
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("Failed to load image, create player with circle");
        }
        draw();
    }

    public void move(int dx, int dy) {
        x += dx;
        y += dy;
        draw();
        System.out.println("Player move to: (" + x + ", " + y + ")"); // For debug outpu
    }

    private void draw() {
        GraphicsContext gc = getGraphicsContext2D();
        gc.clearRect(0, 0, getWidth(), getHeight());

        if (playerImage != null) {
            gc.drawImage(playerImage, x*SIZE, y*SIZE, SIZE, SIZE);
        } else {
            gc.setFill(javafx.scene.paint.Color.RED);
            gc.fillOval(x * SIZE, y * SIZE, SIZE, SIZE);
        }
    }

    public void setPosition(int x, int y) {
        this.x = x;
        this.y = y;
        draw();
    }
}
```

view/PlayerStatusView.java
```java
package main.java.com.sakufuyu.view;

import javafx.scene.control.Label;
import javafx.scene.control.Button;
import javafx.scene.layout.VBox;
import javafx.scene.layout.HBox;

import main.java.com.sakufuyu.model.Player;
import main.java.com.sakufuyu.model.Monster;

public class PlayerStatusView extends VBox {
    private Label nameLabel;
    private Label moneyLabel;
    private Label monstersLabel;
    private Button closeButton;

    public PlayerStatusView() {
        // Initialize UI component
        nameLabel = new Label();
        moneyLabel = new Label();
        monstersLabel = new Label();

        // Close button
        closeButton = new Button("X");
        closeButton.setStyle(
            "-fx-background-color: #f44336;" +
            "-fx-text-fill: white;" +
            "-fx-font-size: 12px;" +
            "-fx-padding: 5px 10px;"
        );
        closeButton.setOnAction(e -> getScene().getWindow().hide());

        // Set style
        this.setSpacing(10);
        this.setPadding(new javafx.geometry.Insets(15));
        this.setStyle("-fx-background-color: rgba(255, 255, 255, 0.8);");

        // Style labels
        nameLabel.setStyle("-fx-font-size: 16px; -fx-font-weight: bold;");
        moneyLabel.setStyle("-fx-font-size: 14px;");
        monstersLabel.setStyle("-fx-font-size: 14px;");

        // Add component
        getChildren().addAll(nameLabel, moneyLabel, monstersLabel, closeButton);
    }

    public void updateStatus(Player player) {
        nameLabel.setText("Player: " + player.getName());
        moneyLabel.setText("Money: " + player.getMoney());

        // Monsters info
        StringBuilder monstersInfo = new StringBuilder("Monsters: \n");
        for (Monster monster: player.getMonsters()) {
            monstersInfo.append(String.format("- %s (HP: %d/%d)\n",
            monster.getName(),
            monster.getHp(),
            monster.getMaxHp()));
        }
        monstersLabel.setText(monstersInfo.toString());
    }
}
```

model/Battle.java
```java
package main.java.com.sakufuyu.model;

public class Battle {
    private Monster playerMonster;
    private Monster wildMonster;

    public Battle(Monster playerMonster, Monster wildMonster) {
        this.playerMonster = playerMonster;
        this.wildMonster = wildMonster;
    }

    public int calculateDamage(Monster attacker, Monster defender) {
        // Calcurate damage with type compativility
        double typeMultiplier = getTypeMultiplier(attacker.type, defender.type);
        int baseDamage = attacker.getAttack() - defender.getDefense();

        return Math.max(1, (int)(baseDamage * typeMultiplier));
    }

    private double getTypeMultiplier(Type attackerType, Type defenderType) {
        if (attackerType == Type.FIRE && defenderType == Type.GRASS) return 2.0;
        if (attackerType == Type.GRASS && defenderType == Type.WATER) return 2.0;
        if (attackerType == Type.WATER && defenderType == Type.FIRE) return 2.0;
        if (attackerType == defenderType) return 1.0;
        return 0.5;
    }

    public boolean isOver() {
        return playerMonster.getHp() <= 0 || wildMonster.getHp() <= 0;
    }

    public Monster getWinner() {
        if (!isOver()) return null;
        return playerMonster.getHp() > 0 ? playerMonster : wildMonster;
    }

    // Getter
    public Monster getPlayerMonster() {return playerMonster;}
    public Monster getWildMonster() {return wildMonster;}
}
```

model/Character.java
```java
package main.java.com.sakufuyu.model;

public abstract class Character {
    protected String name;
    protected Type type;
    protected int hp;

    public Character(String name, Type type, int hp) {
        this.name = name;
        this.type = type;
        this.hp = hp;
    }

    // Getters and Setters
}
```

model/Monster.java
```java
package main.java.com.sakufuyu.model;

public class Monster extends Character {
    private int id;
    private int level;
    private int maxHp;
    private int attack;
    private int defense;
    private String description;

    public Monster(MonsterData data) {
        super(data.getName(), data.getType(), data.getBaseHp());
        this.id = data.getId();
        this.level = 1;
        this.maxHp = data.getBaseHp();
        this.attack = data.getBaseAttack();
        this.defense = data.getBaseDefense();
        this.description = data.getDescription();
    }

    public Monster(MonsterData data, int level) {
        this(data);
        this.level = level;
        calculateStats();
    }

    private void calculateStats() {
        maxHp = (hp * level) / 50 + 10;
        hp = maxHp;
        attack = (attack * level) / 50 + 5;
        defense = (defense * level) / 50 + 5;
    }

    // Getters
    public int getId() {return id;}
    public int getLevel() {return level;}
    public int getHp() {return hp;}
    public int getMaxHp() {return maxHp;}
    public int getAttack() {return attack;}
    public int getDefense() {return defense;}
    public String getDescription() {return description;}
    public String getName() {return name;}

    // Setters
    public void setHp(int hp) {this.hp = Math.max(0, hp);}

    public void levelUp() {
        level++;
        calculateStats();
    }

    @Override
    public String toString() {
        return String.format("Monster{name=%s, type=%s, level=%d, hp=%d/%d}",name, type, level, hp, maxHp);
    }
}
```

model/MonsterData.java
```java
package main.java.com.sakufuyu.model;

public class MonsterData {
    private int id;
    private String name;
    private Type type;
    private int baseHp;
    private int baseAttack;
    private int baseDefense;
    private String description;

    public MonsterData(int id, String name, Type type, int baseHp, int baseAttack, int baseDefense, String description) {
        this.id = id;
        this.name = name;
        this.type = type;
        this.baseHp = baseHp;
        this.baseAttack = baseAttack;
        this.baseDefense = baseDefense;
        this.description = description;
    }

    // Getters and Setters
    public int getId() {return id;}
    public void setId(int id) {this.id = id;}

    public String getName() {return name;}

    public Type getType() {return type;};

    public int getBaseHp() {return baseHp;}
    public void setBaseHp(int baseHp) {this.baseHp = baseHp;}

    public int getBaseAttack() {return baseAttack;}
    public void setBaseAttack(int baseAttack) {this.baseAttack = baseAttack;}

    public int getBaseDefense() {return baseDefense;}
    public void setBaseDefense(int baseDefense) {this.baseDefense = baseDefense;}

    public String getDescription() {return description;}
}
```

model/Player.java
```java
package main.java.com.sakufuyu.model;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Player {
    private String name;
    private List<Monster> monsters;
    private int money;
    private Map<String, Integer> items;
    private static final int MAX_MONSTERS = 6;

    public Player(String name) {
        this.name = name;
        this.monsters = new ArrayList<>();
        this.money = 0;
        this.items = new HashMap<>();

        this.items.put("Monster Ball", 10);
        this.items.put("Potion", 10);
    }

    // Getter methods
    public String getName() {
        return name;
    }
    public List<Monster> getMonsters() {
        return monsters;
    }
    public int getMoney() {
        return money;
    }
    public Map<String, Integer> getItems() {
        return items;
    }

    // Setter methods
    public void addMonster(Monster monster) {
        monsters.add(monster);
    }
    public void setMoney(int money) {
        this.money = money;
    }
    public void addItem(String itemName) {
        int count = items.get(itemName);
        items.put(itemName, count + 1);
    }
    public void removeItem(String item) {
        items.remove(item);
    }

    // Other methods
    public Monster getActiveMonster() {
        // Return the first monster in the list
        for (int i = 0; i < monsters.size(); i++) {
            if (monsters.get(i).getHp() > 0) return monsters.get(i);
        }
        return null;
    }

    public void switchActiveMonster(int index) {
        if (index >= 0 && index < monsters.size()) {
            Monster temp = monsters.get(0);
            monsters.set(0, monsters.get(index));
            monsters.set(index, temp);
        }
    }

    // Catch wild monster
    public boolean captureMonster(Monster monster) {
        if (monsters.size() >= MAX_MONSTERS) {
            return false;
        }
        monsters.add(monster);
        return true;
    }

    // Release monster
    public boolean releaseMonster(int index) {
        int monster_size = monsters.size();
        if (index < 0 || index >= monster_size || monster_size <= 1) {
            return false;
        }
        monsters.remove(index);
        return true;
    }

    // Recovery all monsters
    public void healAllMonsters() {
        for (Monster monster: monsters) {
            monster.setHp(monster.getMaxHp());
        }
    }

    public boolean hasActivemonster() {
        for (Monster monster: monsters) {
            if (monster.getHp() > 0) return true;
        }
        return false;
    }

    // Increase money
    public void addMoney(int amount) {
        this.money += amount;
    }

    // Reduce money
    public boolean spendMoney(int amount) {
        if (this.money >= amount) {
            this.money -= amount;
            return true;
        }
        return false;
    }

    // Change monster order
    public boolean swapMonsters(int index1, int index2) {
        int monsters_size = monsters.size();
        if (index1 < 0 || index1 >= monsters_size || index2 < 0 || index2 >= monsters_size) {
            return false;
        }

        Monster temp = monsters.get(index1);
        monsters.set(index1, monsters.get(index2));
        monsters.set(index2, temp);

        return true;
    }

    public String getStatus() {
        StringBuilder status = new StringBuilder();
        status.append("Player: ").append(name).append("\n");
        status.append("Money: ").append(money).append("\n");
        status.append("Monsters:\n");
        for (int i = 0; i < monsters.size(); i++) {
            Monster m = monsters.get(i);
            status.append(String.format("%d: %s (HP: %d/%d)\n", 
                i + 1, m.getName(), m.getHp(), m.getMaxHp()));
        }
        return status.toString();
    }


    // Items related methods

    public boolean hasItem(String itemName) {
        return items.containsKey(itemName) && items.get(itemName) > 0;
    }

    public boolean useItem(String itemName) {
        if (hasItem(itemName)) {
            int count = items.get(itemName);
            items.put(itemName, count - 1);

            if (items.get(itemName) <= 0) {
                items.remove(itemName);
            }
            return true;
        }
        return false;
    }
}
```

model/Type.java
```java
package main.java.com.sakufuyu.model;

public enum Type {
    FIRE, GRASS, WATER
}
```

controller/BattleController.java
```java
package main.java.com.sakufuyu.controller;

import java.util.Map;
import java.util.Random;

import main.java.com.sakufuyu.model.Battle;
import main.java.com.sakufuyu.view.BattleView;
import main.java.com.sakufuyu.view.GameView;
import main.java.com.sakufuyu.model.Monster;
import main.java.com.sakufuyu.model.Player;

public class BattleController {
    private BattleView battleView;
    private Battle battle;
    private Random random;
    private GameController gameController;
    private static final String[] CPU_CHOICES = {"Rock", "Scissors", "Paper"};
    private static final String MONSTER_BALL = "Monster Ball";
    private static final double BASE_CAPTURE_RATE = 0.4;

    public BattleController(GameController gameController) {
        this.battleView = new BattleView();
        this.random = new Random();
        this.gameController = gameController;

        setupBattleControls();
    }

    public void startBattle(Player player, Monster wildMonster) {
        if (!player.hasActivemonster()) {
            battleView = new BattleView();
            battleView.showMessage("No monsters available to battle...", wildMonster);

            // Close the battle window
            new Thread(() -> {
                try {
                    Thread.sleep(3000);
                    javafx.application.Platform.runLater(() -> battleView.close());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }).start();
            return;
        }

        battle = new Battle(player.getActiveMonster(), wildMonster);
        battleView.showBattle(player.getActiveMonster(), wildMonster);
        setupBattleControls();
    }

    private void setupBattleControls() {
        battleView.getRockButton().setOnAction(e -> performTurn("Rock"));
        battleView.getPaperButton().setOnAction(e -> performTurn("Paper"));
        battleView.getScissorsButton().setOnAction(e -> performTurn("Scissors"));
        battleView.getThrowButton().setOnAction(e -> attemptCapture());
        updateBallCount();
    }

    private void performTurn(String playerChoice) {
        String cpuChoice = CPU_CHOICES[random.nextInt(3)];

        // 0 = win, 1 = draw, 2 = lose
        int result = isPlayerWinJanken(playerChoice, cpuChoice);

        // Calcurate damage with the result
        if (result == 0) {
            int damage = battle.calculateDamage(
                battle.getPlayerMonster(),
                battle.getWildMonster()
            );
            battle.getWildMonster().setHp(
                battle.getWildMonster().getHp() - damage
            );

            battleView.updateBattleLog(
                String.format("Your %s's attack! %d damage to wild %s!!",
                    battle.getPlayerMonster().getName(),
                    damage,
                    battle.getWildMonster().getName())
            );
        } else if (result == 1) {
            int damage = 1;
            battle.getWildMonster().setHp(
                battle.getWildMonster().getHp() - damage
            );
            battle.getPlayerMonster().setHp(
                battle.getPlayerMonster().getHp() - damage
            );

            battleView.updateBattleLog("Draw!!");
        } else {
            int damage = battle.calculateDamage(
                battle.getWildMonster(),
                battle.getPlayerMonster()
            );
            battle.getPlayerMonster().setHp(
                battle.getPlayerMonster().getHp() - damage
            );

            battleView.updateBattleLog(
                String.format("Wild %s's attack! %d damage to your %s!!",
                    battle.getWildMonster().getName(),
                    damage,
                    battle.getPlayerMonster().getName())
            );
        }

        // Update monsters info
        battleView.updateMonsterInfo(
            battle.getPlayerMonster(),
            battle.getWildMonster()
        );

        // Check if battle is end
        if (battle.isOver()) {
            endBattle(battle.getWinner() == battle.getPlayerMonster());
        }
    }

    private int isPlayerWinJanken(String playerChoice, String cpuChoice) {
        if (playerChoice.equals(cpuChoice)) return 1;
        if ((playerChoice.equals("Rock") && cpuChoice.equals("Scissors")) ||
            (playerChoice.equals("Scissors") && cpuChoice.equals("Paper")) ||
            (playerChoice.equals("Paper") && cpuChoice.equals("Rock"))) {
                return 0;
            }
        return 2;
    }

    private void endBattle(boolean isWin) {
        battleView.updateBattleLog(isWin ? "You Win!!":"You lose...");

        Monster wildMonster = battle.getWildMonster();

        // Wait few seconds and close the window
        new Thread(() -> {
            try {
                Thread.sleep(2000);
                javafx.application.Platform.runLater(() -> {
                    battleView.close();
                    gameController.onBattleEnd(isWin, wildMonster);
                });
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }

    private void updateBallCount() {
        int ballCount = 0;
        Map<String, Integer> items = gameController.getPlayer().getItems();
        if (items.containsKey(MONSTER_BALL)) {
            ballCount = items.get(MONSTER_BALL);
        }
        battleView.updateBallCount(ballCount);
    }

    private void attemptCapture() {
        Player player = gameController.getPlayer();
        if (!player.hasItem(MONSTER_BALL)) {
            battleView.updateBattleLog("No Monster Balls left!");
            return;
        }
        player.useItem(MONSTER_BALL);
        updateBallCount();

        Monster wildMonster = battle.getWildMonster();
        boolean captureSuccess = calculateCaptureSuccess(wildMonster);

        if (captureSuccess) {
            player.captureMonster(wildMonster);
            battleView.showCaptureResult(true);
            endBattle(true);
        } else {
            battleView.showCaptureResult(false);
        }
    }

    private boolean calculateCaptureSuccess(Monster wildMonster) {
        // Wild monster HP is low, possibility to succeede capturing increase
        double hpRatio = (double)wildMonster.getHp()/wildMonster.getMaxHp();
        double captureRate = BASE_CAPTURE_RATE * (2.0 * hpRatio);
        return Math.random() < captureRate;
    }
}
```

controller/GameController.java
```java
package main.java.com.sakufuyu.controller;

import java.util.Random;

import main.java.com.sakufuyu.model.Monster;
import main.java.com.sakufuyu.model.MonsterData;
import main.java.com.sakufuyu.model.Player;
import main.java.com.sakufuyu.repository.MonsterRepository;
import main.java.com.sakufuyu.view.GameView;

public class GameController {
    private GameView view;
    private MonsterRepository monsterRepository;
    private Player player;
    private int playerX = 0;
    private int playerY = 0;
    private Random random = new Random();
    private BattleController battleController;
    private static final int BATTLE_WIN_REWARD = 100; // Get money when win the battle
    private static final int INITIAL_MONEY = 500; // Money at the begining

    public GameController(GameView view) {
        this.view = view;
        this.monsterRepository = new MonsterRepository(); 
        this.player = new Player("Satoshi");
        this.battleController = new BattleController(this);
        setupKeyHandlers();
        initializePlayer();
    }

    public void initializePlayer() {
        // Give a player an initial monster
        player.addMonster(new Monster(monsterRepository.getMonsterById(0), 5));
        player.setMoney(INITIAL_MONEY);
        view.updatePlayerStatus(player);
    }

    public void setupKeyHandlers() {
        view.getScene().setOnKeyPressed(event -> {
            System.out.println("Key pressed:" + event.getCode()); // For debug output
            switch (event.getCode()) {
                case UP:
                    tryMovePlayer(0, -1);
                    break;
                case DOWN:
                    tryMovePlayer(0, 1);
                    break;
                case LEFT:
                    tryMovePlayer(-1, 0);
                    break;
                case RIGHT:
                    tryMovePlayer(1, 0);
                    break;
                default:
                    break;
            }
        });
    }

    private void tryMovePlayer(int dx, int dy) {
        int newX = playerX + dx;
        int newY = playerY + dy;

        if (newX >= 0 && newX < GameView.MAP_WIDTH && newY >= 0 && newY < GameView.MAP_HEIGHT) {
            System.out.println("newX="+newX+", MAP_WIDTH="+GameView.MAP_WIDTH+", newY="+newY+", MAP_HEIGHT="+GameView.MAP_HEIGHT);
            this.playerX = newX;
            this.playerY = newY;
            view.movePlayer(dx, dy);

            // Check if player can heal monsters
            tryHealAtPoint(newX, newY);

            if (view.getMapView().isGrass(newX, newY)) {
                checkEncounter();
            }
        } else {
            System.out.println("Invalid move attempted.");
            System.out.println("newX="+newX+", MAP_WIDTH="+GameView.MAP_WIDTH+", newY="+newY+", MAP_HEIGHT="+GameView.MAP_HEIGHT);
        }
    }

    public void startGame() {
        // Initialize game state
        view.movePlayer(playerX, playerY); // Set initial position
        view.show();
        System.out.println("Game started. Player at: (" + playerX + ", " + playerY + ")"); // For debug output
    }

    private void checkEncounter() {
        if (random.nextDouble() < 0.39) {
            System.out.println("Wild monster appeared!!");
            battleController.startBattle(player, generateWildMonster());
        }
    }

    private Monster generateWildMonster() {
        MonsterData data = monsterRepository.getRandomMonster();
        int level = 1 + random.nextInt(5);
        return new Monster(data, level);
    }

    public Player getPlayer() {
        return player;
    }

    public void onBattleEnd(boolean playerWon, Monster wildMonster) {
        if (playerWon) {
            // Get a reward
            player.addMoney(BATTLE_WIN_REWARD);
            view.showMessage("You won " + BATTLE_WIN_REWARD + " coins!");
        } else {
            // When lose...
            view.showMessage("You lost the battle...");
            teleportToLastHealPoint(); // back to last heal point
        }
        view.updatePlayerStatus(player);
    }

    // private boolean offerCaputure(Monster wildMonster) {
    //     if (player.getMonsters().size() >= 6) {
    //         view.showMessage("Cannot capture more monsters!");
    //         return false;
    //     }

    //     // Succeede capture or not
    //     double captureRate = 0.5 * (1.0 - (double)wildMonster.getHp()/wildMonster.getMaxHp());
    //     if (Math.random() < captureRate) {
    //         player.captureMonster(wildMonster);
    //         return true;
    //     }
    //     return false;
    // }

    // Healing monster
    private void tryHealAtPoint(int x, int y) {
        if (view.getMapView().isHealing(x, y)) {
            player.healAllMonsters();
            view.showMessage("All monsters have been healed!");

            view.updatePlayerStatus(player);
        }
    }
    // Teleport last healing spot when lose battle
    private void teleportToLastHealPoint() {
        playerX = 5;
        playerY = 5;
        view.movePlayer(5 - playerX, 5 - playerY);
    }
}
```

resources/data/monsters.csv
```csv
id,name,type,baseHp,baseAttack,baseDefense,description
1,Firemander,FIRE,45,40,35,A fire-type monster with a burning tail.
2,Watertle,WATER,44,35,40,A water-type monster with a tough shell.
3,Leafasaur,GRASS,45,35,40,A grass-type monster with a leaf on its back.
4,Embear,FIRE,50,45,30,A powerful fire-type monster.
5,Aquabird,WATER,40,35,35,A water-type bird monster.
6,Plantox,GRASS,42,38,38,A toxic grass-type monster.
```

repository/MonsterRepository.java
```java
package main.java.com.sakufuyu.repository;

import main.java.com.sakufuyu.model.MonsterData;
import main.java.com.sakufuyu.model.Type;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;

public class MonsterRepository {
    private Map<Integer, MonsterData> monstersById = new HashMap<>();
    private Random random = new Random();

    public MonsterRepository() {
        loadMonsters();
    }

    private void loadMonsters() {
        String filePath = "src/main/resources/data/monsters.csv";
        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
            // Skip header
            reader.readLine();

            String line;
            while ((line = reader.readLine()) != null) {
                String[] data = line.split(",");
                MonsterData monster = new MonsterData(
                    Integer.parseInt(data[0]),  // id
                    data[1],                    // name
                    Type.valueOf(data[2]),      // type
                    Integer.parseInt(data[3]),  // baseHp
                    Integer.parseInt(data[4]),  // baseAttack
                    Integer.parseInt(data[5]),  // baseDefense
                    data[6]                     // description
                );
                monstersById.put(monster.getId(), monster);
            }
        } catch (IOException e) {
            System.err.println("Error reading monsters.csv:" + e.getMessage());
            // read default monster data
            initializeDefaultMonsters();
        }

        // Read CSV file successfly but no data in the file
        // Load default monster
        if (monstersById.isEmpty()) {
            initializeDefaultMonsters();
        }
    }

    private void initializeDefaultMonsters() {
        addMonster(new MonsterData(0,"Pachichu",Type.FIRE,30,30,30,"Simple rat pachimon."));
    }

    private void addMonster(MonsterData monster) {
        monstersById.put(monster.getId(), monster);
    }

    public MonsterData getMonsterById(int id) {
        return monstersById.get(id);
    }

    public MonsterData getRandomMonster() {
        if (monstersById.isEmpty()) {
            return getMonsterById(0);
        }
        return monstersById.get(random.nextInt(monstersById.size()));
    }

    public List<MonsterData> getAllMonsters() {
        return new ArrayList<>(monstersById.values());
    }
}
```


ご提案いただいた実装手順と各クラスの基本実装は非常に良いスタートポイントです。これらのコードを基に、段階的に機能を追加していくことができます。以下に、次のステップとして実装すべき機能と、それに関連するコード修正や追加のアイデアを提案します：

1. マップの改良:
   - `MapView` クラスを拡張して、異なるタイプのタイル（道路、草むら、水など）を表現します。
   - マップデータを外部ファイル（CSV など）から読み込むように変更します。

2. エンカウントシステムの実装:
   - `GameController` に草むらでのランダムエンカウント機能を追加します。
   - プレイヤーが草むらに入ったときに、一定の確率でバトルを開始するロジックを実装します。

3. バトルシステムの統合:
   - `BattleView` クラスを作成し、バトル画面の UI を実装します。
   - `BattleController` クラスを作成し、じゃんけんゲームのロジックを統合します。
   - タイプ相性によるダメージ計算を実装します。

4. モンスターデータの管理:
   - `Monster` クラスを拡張し、より詳細な属性（攻撃力、防御力など）を追加します。
   - モンスターデータを JSON または CSV ファイルで管理し、ゲーム開始時に読み込むようにします。

5. プレイヤーの状態管理:
   - `Player` クラスに捕獲したモンスターのリストを追加します。
   - プレイヤーの位置や所持アイテムなどの状態を管理するメソッドを実装します。

6. UI の改善:
   - プレイヤーの情報（所持モンスター、HP など）を表示する UI を追加します。
   - バトル中の操作（攻撃選択など）のための UI を実装します。

7. セーブ/ロードシステム:
   - プレイヤーの進行状況を保存/読み込みする機能を実装します。
   - JSON 形式でゲームの状態を保存することを検討します。

8. サウンド効果（オプション）:
   - 簡単な効果音やBGMを追加して、ゲーム体験を向上させます。

これらの機能を順次実装していくことで、基本的なポケモン風ゲームの形になっていきます。各ステップで十分にテストを行い、バグを修正しながら進めることが重要です。












=== ここから ===


